"use strict";(self.webpackChunktailcall_run=self.webpackChunktailcall_run||[]).push([[211],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>c});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=a.createContext({}),l=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=l(e.components);return a.createElement(p.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,p=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=l(n),h=r,c=u["".concat(p,".").concat(h)]||u[h]||m[h]||i;return n?a.createElement(c,o(o({ref:t},d),{},{components:n})):a.createElement(c,o({ref:t},d))}));function c(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=h;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s[u]="string"==typeof e?e:r,o[1]=s;for(var l=2;l<i;l++)o[l]=n[l];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},1645:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>l});var a=n(7462),r=(n(7294),n(3905));const i={title:"Operators"},o=void 0,s={unversionedId:"advanced/operators",id:"advanced/operators",title:"Operators",description:"Tailcall DSL builds on your existing GraphQL knowledge by allowing the addition of some custom operators, termed 'Operators'. These operators provide powerful compile time guarantees to make sure your API composition is tight and robust. It also automatically generates highly optimized resolver logic for your types.",source:"@site/docs/advanced/operators.md",sourceDirName:"advanced",slug:"/advanced/operators",permalink:"/docs/advanced/operators",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/advanced/operators.md",tags:[],version:"current",frontMatter:{title:"Operators"},sidebar:"tutorialSidebar",previous:{title:"N + 1 Problem",permalink:"/docs/advanced/n+1"}},p={},l=[{value:"@server",id:"server",level:3},{value:"@http",id:"http",level:3},{value:"baseURL",id:"baseurl",level:4},{value:"path",id:"path",level:4},{value:"method",id:"method",level:4},{value:"query",id:"query",level:4},{value:"body",id:"body",level:4},{value:"@modify",id:"modify",level:3},{value:"@inline",id:"inline",level:3},{value:"Advanced Topics",id:"advanced-topics",level:2},{value:"Composing Operators",id:"composing-operators",level:3}],d={toc:l},u="wrapper";function m(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Tailcall DSL builds on your existing GraphQL knowledge by allowing the addition of some custom operators, termed 'Operators'. These operators provide powerful compile time guarantees to make sure your API composition is tight and robust. It also automatically generates highly optimized resolver logic for your types."),(0,r.kt)("h3",{id:"server"},"@server"),(0,r.kt)("p",null,"The ",(0,r.kt)("strong",{parentName:"p"},"@server")," operator is utilized to define critical server configurations for your GraphQL application. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql",metastring:"showLineNumbers",showLineNumbers:!0},'schema\n  @server(baseURL: "https://jsonplaceholder.typicode.com", vars: {foo: "bar"}) {\n  query: Query\n  mutation: Mutation\n}\n')),(0,r.kt)("p",null,"In this example, the ",(0,r.kt)("inlineCode",{parentName:"p"},"@server")," operator is added to the GraphQL ",(0,r.kt)("inlineCode",{parentName:"p"},"schema")," definition."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"baseURL"),": We've set \"",(0,r.kt)("a",{parentName:"p",href:"https://jsonplaceholder.typicode.com%22"},'https://jsonplaceholder.typicode.com"')," as our ",(0,r.kt)("inlineCode",{parentName:"p"},"baseURL"),". This means that all API calls made by our GraphQL server defined by ",(0,r.kt)("a",{parentName:"p",href:"#http"},"@http")," will start with this URL.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"vars"),": We've passed in a vars object with a key of ",(0,r.kt)("inlineCode",{parentName:"p"},"foo")," and a value of ",(0,r.kt)("inlineCode",{parentName:"p"},"bar"),". This represents a local variable that could be used by the GraphQL server during its operations."))),(0,r.kt)("h3",{id:"http"},"@http"),(0,r.kt)("p",null,"This ",(0,r.kt)("strong",{parentName:"p"},"@http")," operator serves as an indication of a field or node that is underpinned by a REST API. For Example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql",metastring:"showLineNumbers",showLineNumbers:!0},'type Query {\n  user(id: ID!): User @http(path: "/users")\n}\n')),(0,r.kt)("p",null,"In this example, the ",(0,r.kt)("inlineCode",{parentName:"p"},"@http")," operator is added to the ",(0,r.kt)("inlineCode",{parentName:"p"},"user")," field of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Query")," type. This means that the ",(0,r.kt)("inlineCode",{parentName:"p"},"user")," field is underpinned by a REST API. The ",(0,r.kt)("a",{parentName:"p",href:"#path"},"path")," argument is used to specify the path of the REST API. In this case, the path is ",(0,r.kt)("inlineCode",{parentName:"p"},"/users"),". This means that the GraphQL server will make a GET request to ",(0,r.kt)("inlineCode",{parentName:"p"},"https://jsonplaceholder.typicode.com/users")," when the ",(0,r.kt)("inlineCode",{parentName:"p"},"user")," field is queried."),(0,r.kt)("h4",{id:"baseurl"},"baseURL"),(0,r.kt)("p",null,"This refers to the base URL of the API. If not specified, the default base URL is the one specified in the ",(0,r.kt)("a",{parentName:"p",href:"#server"},"@server")," operator."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql",metastring:"showLineNumbers",showLineNumbers:!0},'type Query {\n  user(id: ID!): User\n    @http(path: "/users", baseURL: "https://jsonplaceholder.typicode.com")\n}\n')),(0,r.kt)("h4",{id:"path"},"path"),(0,r.kt)("p",null,"This refers to the API endpoint you're going to call. For instance ",(0,r.kt)("a",{parentName:"p",href:"https://jsonplaceholder.typicode.com/users%60"},"https://jsonplaceholder.typicode.com/users`"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql",metastring:"showLineNumbers",showLineNumbers:!0},'type Query {\n  user(id: ID!): User @http(path: "/users")\n}\n')),(0,r.kt)("p",null,"If your API endpoint contains dynamic segments, you can use Mustache templates to substitute variables. For example, to fetch a specific user, the path can be written as ",(0,r.kt)("inlineCode",{parentName:"p"},"/users/{{args.id}}"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql",metastring:"showLineNumbers",showLineNumbers:!0},'type Query {\n  user(id: ID!): User @http(path: "/users/{{args.id}}")\n}\n')),(0,r.kt)("h4",{id:"method"},"method"),(0,r.kt)("p",null,"This refers to the HTTP method of the API call. Commonly used methods include GET, POST, PUT, DELETE, etc. If not specified, the default method is GET. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql",metastring:"showLineNumbers",showLineNumbers:!0},'type Mutation {\n  createUser(input: UserInput!): User @http(method: "POST", path: "/users")\n}\n')),(0,r.kt)("h4",{id:"query"},"query"),(0,r.kt)("p",null,"This represents the query parameters of your API call. You can pass it as a static object or use Mustache template for dynamic parameters. These parameters will be added to the URL. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql",metastring:"showLineNumbers",showLineNumbers:!0},'type Query {\n  userPosts(id: ID!): [Post]\n    @http(path: "/posts", query: {userId: "{{args.id}}"})\n}\n')),(0,r.kt)("h4",{id:"body"},"body"),(0,r.kt)("p",null,"The body of the API call. It's used for methods like POST or PUT that send data to the server. You can pass it as a static object or use a Mustache template to substitute variables from the GraphQL variables. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql",metastring:"showLineNumbers",showLineNumbers:!0},'type Mutation {\n  createUser(input: UserInput!): User\n    @http(method: "POST", path: "/users", body: "{{args.input}}")\n}\n')),(0,r.kt)("p",null,"In the example above, the ",(0,r.kt)("inlineCode",{parentName:"p"},"createUser")," mutation sends a POST request to ",(0,r.kt)("inlineCode",{parentName:"p"},"/users"),", with the input object converted to JSON and included in the request body."),(0,r.kt)("h3",{id:"modify"},"@modify"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"@modify")," operator in GraphQL provides the flexibility to alter the attributes of a field or a node within your GraphQL schema. Here's how you can use this operator:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Renaming a Field or Node"),"\nYou can rename a field or a node in your GraphQL schema using the ",(0,r.kt)("inlineCode",{parentName:"li"},"name")," argument in the ",(0,r.kt)("inlineCode",{parentName:"li"},"@modify")," operator. This can be helpful when the field name in your underlying data source doesn't match the desired field name in your schema. For instance:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql",metastring:"showLineNumbers",showLineNumbers:!0},'type User {\n  id: Int! @modify(rename: "userId")\n}\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},'@modify(rename: "userId")')," tells GraphQL that although the field is referred to as ",(0,r.kt)("inlineCode",{parentName:"p"},"id"),"in the underlying data source, it should be presented as ",(0,r.kt)("inlineCode",{parentName:"p"},"userId")," in your schema."),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Excluding a Field or Node"))),(0,r.kt)("p",null,"You can exclude a field or a node from your GraphQL schema using the ",(0,r.kt)("inlineCode",{parentName:"p"},"omit")," argument in the ",(0,r.kt)("inlineCode",{parentName:"p"},"@modify")," operator. This can be useful if you want to keep certain data hidden from the client. For instance:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql",metastring:"showLineNumbers",showLineNumbers:!0},"type User {\n  id: Int! @modify(omit: true)\n}\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"@modify(omit: true)")," tells GraphQL that the ",(0,r.kt)("inlineCode",{parentName:"p"},"id")," field should not be included in the schema, thus it won't be accessible to the client."),(0,r.kt)("h3",{id:"inline"},"@inline"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"@inline")," operator simplifies data structures and fetch processes by 'inlining' or flattening a field or node within your schema. It works by modifying the schema and the data transformation process, essentially streamlining how nested data is accessed and presented."),(0,r.kt)("p",null,"For instance, consider a schema:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql",metastring:"showLineNumbers",showLineNumbers:!0},'schema {\n  query: Query\n}\n\ntype Post {\n  id: Int!\n  user: User!\n}\n\ntype User {\n  id: Int!\n  name: String!\n  email: String!\n  address: Address!\n}\n\ntype Address {\n  street: String!\n  city: String!\n  state: String!\n}\n\ntype Query {\n  postUserStreet(id: Int): Post! @inline(path: ["user", "address", "street"])\n}\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"@inline")," operator, in this case, is applied to the ",(0,r.kt)("inlineCode",{parentName:"p"},"postUserStreet")," field of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Query")," type. It includes a ",(0,r.kt)("inlineCode",{parentName:"p"},"path")," argument, indicating the chain of fields to be traversed from ",(0,r.kt)("inlineCode",{parentName:"p"},"Post")," to the field to be inlined."),(0,r.kt)("p",null,"Post application, the schema becomes:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql",metastring:"showLineNumbers",showLineNumbers:!0},"schema {\n  query: Query\n}\n\ntype Query {\n  postUserStreet(id: Int): String\n}\n")),(0,r.kt)("p",null,"As seen, the ",(0,r.kt)("inlineCode",{parentName:"p"},"Post"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"User"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"Address")," types are eliminated from the schema. The ",(0,r.kt)("inlineCode",{parentName:"p"},"postUserStreet")," now directly returns a ",(0,r.kt)("inlineCode",{parentName:"p"},"String")," representing the address street, thereby simplifying the client-side data fetch process. ",(0,r.kt)("inlineCode",{parentName:"p"},"@inline")," operator also take cares of nullablity of the fields. If any of the fields in the path is nullable, the resulting type will be nullable."),(0,r.kt)("p",null,"Additionally, ",(0,r.kt)("inlineCode",{parentName:"p"},"@inline")," supports indexing, meaning you can specify the array index to be inlined. If a field ",(0,r.kt)("inlineCode",{parentName:"p"},"users")," is of type ",(0,r.kt)("inlineCode",{parentName:"p"},"[User]"),", and you want to inline the first user, you can specify the path as ","[",(0,r.kt)("inlineCode",{parentName:"p"},'"users"'),",",(0,r.kt)("inlineCode",{parentName:"p"},'"0"'),",",(0,r.kt)("inlineCode",{parentName:"p"},'"name"'),"]","."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql",metastring:"showLineNumbers",showLineNumbers:!0},'type Post {\n  firstUser: User @inline(path: ["users", "0", "name"]) @http(path: "/users")\n}\n')),(0,r.kt)("p",null,"In conclusion, the ",(0,r.kt)("inlineCode",{parentName:"p"},"@inline")," operator helps tidy up your schema and streamline data fetching by reducing query depth, promoting better performance and simplicity."),(0,r.kt)("h2",{id:"advanced-topics"},"Advanced Topics"),(0,r.kt)("h3",{id:"composing-operators"},"Composing Operators"),(0,r.kt)("p",null,'This example illustrates the concept of composition in GraphQL, which allows you to combine multiple operations (known as "operators") to build more complex transformations of data.'),(0,r.kt)("p",null,"The given schema is defining two data types - ",(0,r.kt)("inlineCode",{parentName:"p"},"User")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Post"),". The ",(0,r.kt)("inlineCode",{parentName:"p"},"User")," type has fields ",(0,r.kt)("inlineCode",{parentName:"p"},"id")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"name"),", and the ",(0,r.kt)("inlineCode",{parentName:"p"},"Post")," type initially has fields ",(0,r.kt)("inlineCode",{parentName:"p"},"user")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"userId"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql",metastring:"showLineNumbers",showLineNumbers:!0},'type User {\n  id: Int\n  name: String\n}\n\ntype Post {\n  user: User\n    @inline(path: ["name"])\n    @modify(name: "userName")\n    @http(path: "/users/{{userId}}")\n  userId: Int!\n}\n')),(0,r.kt)("p",null,"However, it uses a series of operators to modify the ",(0,r.kt)("inlineCode",{parentName:"p"},"user")," field."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},'@inline(path: ["name"])')," operator is used to drill down into the ",(0,r.kt)("inlineCode",{parentName:"p"},"User")," object, specifically targeting the ",(0,r.kt)("inlineCode",{parentName:"p"},"name")," field. This is equivalent to fetching the ",(0,r.kt)("inlineCode",{parentName:"p"},"User.name")," property.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},'@modify(name: "userName")')," operator is used to rename the inlined ",(0,r.kt)("inlineCode",{parentName:"p"},"name")," field to ",(0,r.kt)("inlineCode",{parentName:"p"},"userName"),". So, instead of a ",(0,r.kt)("inlineCode",{parentName:"p"},"user")," field that is a ",(0,r.kt)("inlineCode",{parentName:"p"},"User")," object, we now have a ",(0,r.kt)("inlineCode",{parentName:"p"},"userName")," field that is a ",(0,r.kt)("inlineCode",{parentName:"p"},"String"),".")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},'@http(path: "/users/{{userId}}")')," operator is used to instruct the resolver to make an HTTP request to fetch the user data from a specified path (i.e., ",(0,r.kt)("inlineCode",{parentName:"p"},"/users/{{userId}}"),"), where ",(0,r.kt)("inlineCode",{parentName:"p"},"{{userId}}")," is a placeholder that would be replaced with the actual ",(0,r.kt)("inlineCode",{parentName:"p"},"userId")," when making the request."))),(0,r.kt)("p",null,"The schema after this transformation looks like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql",metastring:"showLineNumbers",showLineNumbers:!0},"type User {\n  id: Int\n  name: String\n}\n\ntype Post {\n  userName: String\n  userId: Int!\n}\n")),(0,r.kt)("p",null,"So, we've used composition of operators to take a complex object (the ",(0,r.kt)("inlineCode",{parentName:"p"},"User")," inside the ",(0,r.kt)("inlineCode",{parentName:"p"},"Post"),"), extract a specific part of it (",(0,r.kt)("inlineCode",{parentName:"p"},"name"),"), rename that part (",(0,r.kt)("inlineCode",{parentName:"p"},"userName"),"), and then instruct GraphQL how to fetch the data using an HTTP request."),(0,r.kt)("p",null,"This is a powerful mechanism that allows you to make your GraphQL schema more precise, easier to understand, and more suitable for the specific needs of your application."))}m.isMDXComponent=!0}}]);