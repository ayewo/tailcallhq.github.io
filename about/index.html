<!doctype html>
<html lang="en" dir="ltr" class="mdx-wrapper mdx-page plugin-pages plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.1.0">
<title data-rh="true">About | Tailcall</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://tailcall.run/about"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="About | Tailcall"><meta data-rh="true" name="description" content="Tailcall&#x27;s API Developer Platform intends to solve one of the most forsaken pieces of every microservice architecture — API Composition."><meta data-rh="true" property="og:description" content="Tailcall&#x27;s API Developer Platform intends to solve one of the most forsaken pieces of every microservice architecture — API Composition."><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://tailcall.run/about"><link data-rh="true" rel="alternate" href="https://tailcall.run/about" hreflang="en"><link data-rh="true" rel="alternate" href="https://tailcall.run/about" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Tailcall RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Tailcall Atom Feed">

<link rel="preconnect" href="https://www.google-analytics.com">
<script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","G-JEP3QDWT0G","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")</script>
<script async src="https://www.google-analytics.com/analytics.js"></script><link rel="stylesheet" href="/assets/css/styles.fa1376e5.css">
<link rel="preload" href="/assets/js/runtime~main.c902b49b.js" as="script">
<link rel="preload" href="/assets/js/main.38a3b920.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"dark")}()</script><div id="__docusaurus">
<div role="region" aria-label="theme.common.skipToMainContent"><a href="#" class="skipToContent_fXgn">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="Tailcall Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.svg" alt="Tailcall Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">Tailcall</b></a></div><div class="navbar__items navbar__items--right"><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/about">About</a><a href="https://github.com/tailcallhq" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper mainWrapper_z2l0"><main class="container container--fluid margin-vert--lg"><div class="row mdxPageWrapper_j9I6"><div class="col col--8"><article><p>Tailcall&#x27;s <strong>API Developer Platform</strong> intends to solve one of the most forsaken pieces of every microservice architecture — API Composition.
Some of the ideas used in tailcall&#x27;s solution are developed over years of experience in working at scale.
Before we go deeper into API Composition, let&#x27;s do a quick recap of what a microservice architecture looks like</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="microservice">Microservice<a class="hash-link" href="#microservice" title="Direct link to heading">​</a></h2><p>Microservices architecture is a design pattern in which a large application is built as a suite of modular services, each of which runs its process and communicates with other services through well-defined interfaces, typically using a lightweight messaging protocol. This approach has several benefits over a monolithic architecture, including improved scalability, resilience, and maintainability. In a microservices architecture, each service has a specific role and is independently deployable, so developers can work on different services in parallel and deploy them independently of each other. This can make the development process more agile and allow for faster deployment of new features.</p><p><img loading="lazy" alt="microservice" src="/assets/images/microservices-470f369493a95674ec72436df9d40ce3.svg" width="3014" height="2260" class="img_ev3q"></p><p>An API gateway is a server that acts as a single point of entry for certain types of requests. It can receive requests from the client, route them to the appropriate backend service, and then return the response from the backend service to the client. An API gateway can also perform tasks such as authentication, rate limiting, and caching. This makes it a useful component in a microservices architecture, where each service has its API and the API gateway acts as the &quot;front door&quot; for clients to access the services.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="api-composition">API Composition<a class="hash-link" href="#api-composition" title="Direct link to heading">​</a></h2><p>API composition refers to the process of combining multiple APIs to create a new API or a new functionality. This can be done by sending requests to multiple APIs and combining the results, or by creating a new API that acts as a façade for the underlying APIs.</p><p>For example, consider a scenario where a client application wants to display a user&#x27;s profile information and recent posts on a social media platform. In this case, the client can send two separate requests to two different APIs: one to retrieve the user&#x27;s profile information, and another to retrieve their recent posts. The client can then combine the results from these two APIs to create a single response that contains all the required information. This new response can be considered as the output of the composed API.</p><p>To build a rich user interface, API composition is necessary on the client side.
One of the main challenges with API composition on the client side is that it can lead to increased complexity in the client application. This is because the client needs to handle the process of sending requests to multiple APIs and combining the results, which can add to the overall size and complexity of the client code.</p><p>Another challenge with API composition on the client side is that it can result in reduced performance and increased latency. This is because the client needs to make multiple separate requests to different APIs, which can take more time and result in a slower response from the composed API.</p><p>In addition, API composition on the client side can also lead to increased security risks. This is because the client needs to handle sensitive information, such as API keys and authentication credentials, which can be vulnerable to attacks if not properly secured.
The client doesn&#x27;t have access to powerful CPUs or a reliable network either. This makes the composition problem even more challenging to implement and manage. It is therefore often more efficient and effective to perform API composition on the server side instead.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="backend-for-frontend">Backend For Frontend<a class="hash-link" href="#backend-for-frontend" title="Direct link to heading">​</a></h2><p>A BFF layer can help to solve the challenges of API composition by providing a separate backend service that is optimized for each specific frontend client. This can enable the BFF to perform API composition on behalf of the client, which can help to improve the performance and reliability of the composed API. The BFF layer typically sits as a separate component in the overall architecture, between the frontend client and the microservices. It can communicate with both the frontend client and the microservices using well-defined interfaces and protocols, such as REST or gRPC.</p><p>The BFF can take advantage of a powerful CPU and access to a fast network to improve the performance and reliability of the composed API. It can also provide added flexibility and control over the composition process. This can make it a useful tool for developers who want to create new APIs by combining the functionality of multiple underlying APIs.</p><p><img loading="lazy" alt="Backend for Frontend" src="/assets/images/bff-878ce671177c6fa3e99bf82f002c2b17.svg" width="3617" height="2224" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="highly-specialized">Highly Specialized<a class="hash-link" href="#highly-specialized" title="Direct link to heading">​</a></h3><p>One of the challenges with using a BFF layer is that it is a highly specialized solution that requires a significant amount of hand-written code. Unlike an API gateway, there is no standard BFF solution that can be deployed out-of-the-box, and each BFF implementation must be custom-tailored to the specific requirements of the frontend client. This lack of standardization and reusability can make the BFF solution more complex and difficult to maintain.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="fragile">Fragile<a class="hash-link" href="#fragile" title="Direct link to heading">​</a></h3><p>Another challenge with using a BFF layer is that it can be fragile and susceptible to failure. The BFF solution is dependent on the developers to follow best practices and handle all error scenarios, and if these steps are not taken, the solution can be prone to bugs and performance issues. Additionally, the BFF solution must be thoroughly tested, including performance testing, unit testing, and integration testing, to ensure that it is reliable and performs well in production. This can require significant effort and expertise, and if these steps are not properly followed, the BFF solution can be fragile and prone to failure. Also, it&#x27;s worth mentioning that a BFF layer is an entry point to all your backend, it going down basically means nothing is accessible for the user so this layer needs to be robust and resilient to exceptions.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="performance">Performance<a class="hash-link" href="#performance" title="Direct link to heading">​</a></h3><p>Because BFF layers are typically custom-written for each use case, it can be difficult to predict the performance impact of a small code change. Issues such as unoptimized algorithms, inefficient caching, and unnecessary downstream requests can go unnoticed and only be discovered very late in the development cycle. Typically companies perform thorough benchmarking and load testing before anything goes live. This results in a very high time to market even for minor changes.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="monolith">Monolith<a class="hash-link" href="#monolith" title="Direct link to heading">​</a></h3><p>Eventually, this layer turns out to be a big monolith touching every service in your backend. The layer contains a lot of handwritten spaghetti code that&#x27;s hard to maintain. Onboarding new engineers also become harder and upgrading libraries or architecture gets costlier. Any tiny change requires a full-fledged deployment on your infrastructure.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="canary-support-lack-thereof">Canary Support (Lack thereof)<a class="hash-link" href="#canary-support-lack-thereof" title="Direct link to heading">​</a></h3><p>Every change that happens in the backend requires the deployment of the BFF layer. In fact, any feature that is built on the client also requires changes on the BFF layer. Such frequent changes can not be exposed to 100% of users because the reliability and performance of this system are unknown. A common way to solve this problem is to use <a href="https://www.redhat.com/en/topics/devops/what-is-blue-green-deployment" target="_blank" rel="noopener noreferrer">Blue Green</a> deployments. This requires additional infrastructure and complex routing mechanisms. A first-class support to do canary releases is very important and should be part of a modern BFF layer, however, most companies rely on DevOps for its support.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="coupled-release">Coupled Release<a class="hash-link" href="#coupled-release" title="Direct link to heading">​</a></h3><p>BFF layers can&#x27;t be deployed independently since they act as a bridge between the clients and the services. Generally, the services need to go live first, and they need to make sure that the change is compatible with the current version of the BFF layer running in production. The interesting problem is in case there is a bug in the microservice and it needs to be reverted, even the BFF layer needs to be reverted. This kind of coupling makes it operationally very expensive to manage.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="legacy-gateway">Legacy Gateway<a class="hash-link" href="#legacy-gateway" title="Direct link to heading">​</a></h3><p>BFF layers often end up implementing some of the cross-cutting concerns of an API gateway such as rate limiting, authentication, throttling etc. This makes its purpose quite confusing in the sense that do we need an API gateway if we are using a BFF layer? Moreover, it&#x27;s not very clear if we use an API gateway with a BFF layer, where should we place it? Should we place it between the clients and the BFF layer or the BFF layer and the service mesh? These are subjective decisions that each company ends up making as there is no standard way of doing this. However, it&#x27;s worth mentioning that legacy gateways do introduce a gap that&#x27;s being attempted to be filled by a BFF layer.</p><hr><p><strong>PS:</strong> If you were looking for the technical meaning of tailcall then the following might be a good starting point -</p><p>From <em><a href="https://en.wikipedia.org/wiki/Tail_call" target="_blank" rel="noopener noreferrer">Wikipedia</a></em></p><blockquote><p>In computer science, a tail call is a subroutine call performed as the final action of a procedure.</p></blockquote><p>The basic idea is that it&#x27;s a function call that is made at a place where no stack allocations are required. This happens when the caller of the function is simply returning the result of the called function. This optimization doesn&#x27;t have any performance impact however it gives us the flexibility to design and implement mutually recursive functions.</p></article></div><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#microservice" class="table-of-contents__link toc-highlight">Microservice</a></li><li><a href="#api-composition" class="table-of-contents__link toc-highlight">API Composition</a></li><li><a href="#backend-for-frontend" class="table-of-contents__link toc-highlight">Backend For Frontend</a><ul><li><a href="#highly-specialized" class="table-of-contents__link toc-highlight">Highly Specialized</a></li><li><a href="#fragile" class="table-of-contents__link toc-highlight">Fragile</a></li><li><a href="#performance" class="table-of-contents__link toc-highlight">Performance</a></li><li><a href="#monolith" class="table-of-contents__link toc-highlight">Monolith</a></li><li><a href="#canary-support-lack-thereof" class="table-of-contents__link toc-highlight">Canary Support (Lack thereof)</a></li><li><a href="#coupled-release" class="table-of-contents__link toc-highlight">Coupled Release</a></li><li><a href="#legacy-gateway" class="table-of-contents__link toc-highlight">Legacy Gateway</a></li></ul></li></ul></div></div></div></main></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Contact</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://discord.gg/7fseDEXUNU" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord</a></li><li class="footer__item"><a href="mailto:hi@tailcall.run" target="_blank" rel="noopener noreferrer" class="footer__link-item">hi@tailcall.run</a></li><li class="footer__item"><a href="https://www.linkedin.com/company/tailcall" target="_blank" rel="noopener noreferrer" class="footer__link-item">Linkedin</a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 Tailcall, Inc. </div></div></div></footer></div>
<script src="/assets/js/runtime~main.c902b49b.js"></script>
<script src="/assets/js/main.38a3b920.js"></script>
</body>
</html>